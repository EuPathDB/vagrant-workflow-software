---
- hosts: all
  sudo: yes

  tasks:

      # Some resources are behind firewalls and access rules. Test early
      # that we have access to them.
    - name: testing access to restricted URL
      get_url: url=http://software.apidb.org/source/
               dest=/dev/null
               force=yes
      changed_when: false

    - name: change sysadmin user group
      group: name="{{ wf_shared_group }}" state=present
    - user: name="{{ sysadmin }}"
            group="{{ wf_shared_group }}"
      register: disconnect
    - name: disconnect
      # Force ssh reconnect to get a new shell with updated group info (so files get
      # correct group ownership). This is done by killing the client ssh multiplex process
      # on the ansible driver.
      local_action: command pkill -f "ansible-ssh-{{ ansible_ssh_host }}-{{ ansible_ssh_port }}-"
      sudo: no
      when: disconnect|changed

    - file: path=/home/{{ sysadmin }}/bin
            state=directory

    - template: dest=/usr/bin/wfpkginstall
                src=templates/wfpkginstall.j2
                owner="{{ sysadmin }}"
                mode=755
    - template: dest=/etc/profile.d/wfpkginstall.completion.sh
                src=templates/wfpkginstall.completion.sh.j2
                mode=644

    - name: install python-hashlib # for yumdownloader/yum 3.2.22
      yum:  name=python-hashlib
      when: ansible_distribution_major_version == '5'
    - name: install zlib-devel
      yum:  name=zlib-devel
    - name: install git
      yum:  name=git

    - name: Create base directory
      file: path="{{ wf_user_path }}"
            state=directory
            owner="{{ sysadmin }}"
            group="{{ wf_shared_group }}"

    - name: add git host to known_hosts
      known_hosts: path="/home/{{ sysadmin }}/.ssh/known_hosts"
                   host='git.apidb.org'
                   key="{{ lookup('pipe','ssh-keyscan git.apidb.org') }}"
      sudo: no

    - name: initialize sysadmin directory (this will take a while)
      script: bin/init.sh "{{ wf_user_path }}"
              creates="{{ wf_user_path }}/sysadmin"
      sudo: no

    - name: add workflow user
      user: name="{{ wf_user }}"
            group="{{ wf_shared_group }}"
            shell=/bin/bash

      # Set a shell prompt that clearly distinguishes this VM from a real server of
      # the same name (to help avoid accidentally doing dev work on the real server
      # when you terminals open to both).
    - name: set shell prompt
      lineinfile: dest=/home/{{ item.user }}/.bash_profile
                  regexp="^export PS1="
                  line='export PS1="[\[$(tput setaf 1)\]\[$(tput bold)\]Simulated \[$(tput sgr0)\]\u@\h \W]\\n\[$(tput setaf 2)\]\\$ \[$(tput sgr0)\]\[$(tput sgr0)\]"'
      with_items:
        - { user: "{{ sysadmin }}" }
        - { user: "{{ wf_user }}" }

    - name: fetch vagrant authorized_keys
      fetch: src=/home/vagrant/.ssh/authorized_keys
             dest=scratch/authorized_keys
             flat=yes

    - name: workflow user authorized_keys
      authorized_key: user="{{ wf_user }}"
                      key="{{ lookup('file', 'scratch/authorized_keys') }}"

    - name: install workflow bashrc
      copy: src=files/workflow_bashrc
            dest="/home/{{ wf_user }}/.bashrc"
            owner="{{ wf_user }}"
            mode=0644

    - name: patch sysadmin bashrc
      lineinfile: dest="/home/{{ sysadmin }}/.bashrc"
                  regexp="^export admin_path={{ wf_user_path }}/sysadmin"
                  line="export admin_path={{ wf_user_path }}/sysadmin"
    - name: patch sysadmin bashrc
      lineinfile: dest="/home/{{ sysadmin }}/.bashrc"
                  regexp="^export eupath_dir={{ wf_user_path }}"
                  line="export eupath_dir={{ wf_user_path }}"

    - name: run workpuppet (this may take a while)
      script: bin/runworkpuppet.sh "{{ wf_user_path }}"
      sudo: no
      changed_when: false
